<!-- Source: https://bl.ocks.org/mbostock/3231298 -->

<!DOCTYPE html>
<meta charset="utf-8">

<head>
  <style type="text/css">
        body { background-color: rgb(34, 34, 34);}
        .node { stroke: #fff; color: #eee; fill:azure; font-size: 40px; }

        .link { stroke: #999; stroke-opacity: .6; stroke-width: 10px; }

        .MathJax_SVG svg > g, 
        .MathJax_SVG_Display svg > g { 
            fill: rgb(240, 182, 182);
            stroke: rgb(235, 230, 230);
        } 
    </style>
</head>
<body>
<script src="https://d3js.org/d3.v6.min.js"></script>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js"></script>
<script>



var width = 960,
    height = 700;

    var _transitions = [],
        _inverse_transitions = [];


function getLinkAnchors(d) {
  const srcEle = d3.select("#" + d.source.id);//.select("text");
  const srcBB = srcEle.node().getBBox();
  const dstEle = d3.select("#" + d.target.id);//.select("text");
  const dstBB = dstEle.node().getBBox();
  var result = {start: {x: 0, y: 0}, end: {x: 0, y:0}};

  result.start.x = srcBB.x + 0.5*srcBB.width + d.source.x;
  result.start.y = srcBB.y + 0.5*srcBB.height + d.source.y;
  result.end.x = dstBB.x + 0.5*dstBB.width + d.target.x;
  result.end.y = dstBB.y + 0.5*dstBB.height + d.target.y;

  const srcPoints = [
    {x: srcBB.x + d.source.x, y: srcBB.y + d.source.y},
    {x: srcBB.x + srcBB.width + d.source.x, y: srcBB.y + d.source.y},
    {x: srcBB.x + srcBB.width + d.source.x, y: srcBB.y + srcBB.height + d.source.y},
    {x: srcBB.x + d.source.x, y: srcBB.y + srcBB.height + d.source.y}
  ];
  const dstPoints = [
    {x: dstBB.x + d.target.x, y: dstBB.y + d.target.y},
    {x: dstBB.x + dstBB.width + d.target.x, y: dstBB.y + d.target.y},
    {x: dstBB.x + dstBB.width + d.target.x, y: dstBB.y + dstBB.height + d.target.y},
    {x: dstBB.x + d.target.x, y: dstBB.y + dstBB.height + d.target.y}
  ]

  for (var i = 0; i < srcPoints.length; i++) {
    var det, gamma, lambda;
    var s1 = srcPoints[i];
    var s2 = i == srcPoints.length - 1 ? srcPoints[0] : srcPoints[i+1];
    det = (result.end.x - result.start.x) * (s2.y - s1.y) - (s2.x - s1.x) * (result.end.y - result.start.y);
    if (det === 0)
      continue;
    lambda = ((s2.y - s1.y) * (s2.x - result.start.x) + (s1.x - s2.x) * (s2.y - result.start.y)) / det;
    gamma = ((result.start.y - result.end.y) * (s2.x - result.start.x) + (result.end.x - result.start.x) * (s2.y - result.start.y)) / det;
    if ((0 < lambda && lambda < 1) && (0 < gamma && gamma < 1)) {
      // HIT!
      result.start.x = result.start.x + lambda * (result.end.x - result.start.x);
      result.start.y = result.start.y + lambda * (result.end.y - result.start.y);
      break;
    }
  }

  for (var i = 0; i < dstPoints.length; i++) {
    var det, gamma, lambda;
    var s1 = dstPoints[i];
    var s2 = i == dstPoints.length - 1 ? dstPoints[0] : dstPoints[i+1];
    det = (result.start.x - result.end.x) * (s2.y - s1.y) - (s2.x - s1.x) * (result.start.y - result.end.y);
    if (det === 0)
      continue;
    lambda = ((s2.y - s1.y) * (s2.x - result.end.x) + (s1.x - s2.x) * (s2.y - result.end.y)) / det;
    gamma = ((result.end.y - result.start.y) * (s2.x - result.end.x) + (result.start.x - result.end.x) * (s2.y - result.end.y)) / det;
    if ((0 < lambda && lambda < 1) && (0 < gamma && gamma < 1)) {
      // HIT!
      result.end.x = result.end.x + lambda * (result.start.x - result.end.x);
      result.end.y = result.end.y + lambda * (result.start.y - result.end.y);
      break;
    }
  }
  return result;
}

function linkArc(d) {
  var anchors = getLinkAnchors(d);
  const r = Math.hypot(anchors.end.x - anchors.start.x, anchors.end.y - anchors.start.y);
  return `
    M${anchors.start.x},${anchors.start.y}
    A${r},${r} 0 0,0 ${anchors.end.x},${anchors.end.y}
  `;
}

data = {
    nodes: [{id: "sample_domains", opacity: 1, fx: 150, fy: 150, labels: [
              {text: "sample domains"},
              {math: "\\theta_{1:n_c}",                  offset: "-30px, 10px"},
              {math: "\\theta^{1:n_G}_{\\xi_{1:n_r}}", offset: "30px, 8px"}
            ]},
            {id: "train_candidate", opacity: 0, fx: 250, fy: 300, labels: [
              {text: "train candidate and"},
              {text: "reference policies",             offset: "5px, 12px"},
              {math: "\\theta^\\star_{n_c}",           offset: "-30px, 20px"},
              {math: "\\theta^{1:n_{G,\\star}}_{n_r}", offset: "30px, 16px"}
            ]},
            {id: "evaluate",     opacity: 0, fx: 420, fy: 360, labels: [
              {text: "evaluate in"},
              {text: "reference domains", offset: "0px, 12px"},
              {math: "G^{1:n_G}_{{n}_{r},1:n_{r}}", offset: "0px, 24px"}
            ]},
            {id: "bootstrap",    opacity: 0, fx: 650, fy: 300, labels: [
              {text: "bootstrap upper"},
              {text: "confidence bound", offset: "0px, 12px"},
              {math: "G^U_{n_r}(\\theta^\\star_{n_c})", offset: "0px, 24px"}
            ]},
            {id: "small",       opacity: 0, fx: 650, fy: 160, labels: [
              {text: "small enough?"}
            ]},
            {id: "increase",    opacity: 0, fx: 400, fy: 150, labels: [
              {text: "increase number of domains"},
              {math: "n_c,n_r\\leftarrow f(n_c),f(n_r)", offset: "-64px, 16px"}
            ]},
            {id: "done",       opacity: 0, fx: 750, fy: 100, labels: [
              {text: "done"}
            ]}
          ],
    links: [{source: "sample_domains", target: "train_candidate", type: "A"},
            {source: "train_candidate", target: "evaluate", type: "A"},
            {source: "evaluate", target: "bootstrap", type: "A"},
            {source: "bootstrap", target: "small", type: "B"},
            {source: "small", target: "done", type: "C"},
            {source: "small", target: "increase", type: "D"},
            {source: "increase", target: "sample_domains", type: "A"}
           ]
};

types = Array.from(new Set(data.links.map(d => d.type)));
color = d3.scaleOrdinal(types, d3.schemeCategory10);

  const links = data.links.map(d => Object.create(d));
  const nodes = data.nodes.map(d => Object.create(d));

  const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id))
      .force("charge", d3.forceManyBody().strength(-800))
      .force("x", d3.forceX(width/2))
      .force("y", d3.forceY(height/3));

drag = simulation => {
  
  function dragstarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }
  
  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }
  
  function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
  
  return d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);
}
      
  const svg = d3.select("body").append("div").append("svg")
        .attr("viewBox", [0, 0, width, height])
        .style("font", "12px sans-serif")
        .style("width", "98%")
        .style("height", "98%");

  // Per-type markers, as they don't inherit styles.
  svg.append("defs").selectAll("marker")
    .data(types)
    .join("marker")
      .attr("id", d => `arrow-${d}`)
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 8)
      .attr("refY", -0.5)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
    .append("path")
      .attr("fill", color)
      .attr("d", "M0,-5L10,0L0,5");

  const link = svg.append("g")
      .attr("fill", "none")
      .attr("stroke-width", 2.0)
    .selectAll("path")
    .data(links)
    .join("path")
      .attr("stroke", d => color(d.type))
      .attr("marker-end", d => `url(${new URL(`#arrow-${d.type}`, location)})`)
      .attr("id", d => d.source.id + "-" + d.target.id)
      .attr("opacity", 0.0);

  const node = svg.append("g")
      .attr("fill", "white")
      .attr("stroke-linecap", "round")
      .attr("stroke-linejoin", "round")
    .selectAll("g")
    .data(nodes)
      .join("g")
        .attr("id", d => d.id)
        .attr("opacity", d => d.opacity)
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
    .call(drag(simulation));

  // node.append("circle")
  //     .attr("stroke", "white")
  //     .attr("fill", "#99a")
  //     .attr("stroke-width", 1.5)
  //     .attr("r", 4);

  node.append(function(d) {
    const wrapNode = d3.create("svg:g");
    d.labels.forEach((label) => {
      console.log(label);
      if (label.math) {
        const mathNode = d3.create("svg:g");
        mathNode
          .style("transform", "translate(" + (label.offset || "0px, 0px") + ")")
          .style("text-anchor", "middle")
          .attr("color", "#eee")
          .append(s => MathJax.tex2svg(label.math).querySelector("svg"));
        wrapNode.append(() => mathNode.node());
      } else if (label.text) {
        const textNode = d3.create("svg:text");
        textNode
          .style("transform", "translate(" + (label.offset || "0px, 0px") + ")")
          .style("text-anchor", "middle")
          .attr("color", "#aae")
          .text(label.text);
        wrapNode.append(() => textNode.node());
      } else {
        throw "Node label contains no supported data!";
      }
    });
    return wrapNode.node();
  });

  simulation.on("tick", () => {
    link.attr("d", linkArc);
    node.attr("transform", d => `translate(${d.x},${d.y})`);
  });

function showNode(idx, show) {
    const node_id = nodes[idx].id;
    const node = d3.select("#" + node_id);
    
    if (show) {
        node.transition().attr("opacity", 1.0);
        
    } else {
        node.transition().attr("opacity", 0.0);
    }

    setTimeout(function() {
      var edges = [];
      links.forEach(link => {
          if (link.target.id == node_id && d3.select("#" + link.source.id).attr("opacity") > 0 ||
              link.source.id == node_id && d3.select("#" + link.target.id).attr("opacity") > 0)
            edges.push(link);
      });

      if (show) {
        edges.forEach(e => {
            d3.select("#" + e.source.id + "-" + e.target.id).transition().attr("opacity", 1.0);
        });
      } else {
        edges.forEach(e => {
            d3.select("#" + e.source.id + "-" + e.target.id).transition().attr("opacity", 0.0);
        });
      }
    }, 50);
}

_transitions.push(
    () => showNode(1, true)
)
_inverse_transitions.push(
    () => showNode(1, false)
)

_transitions.push(
    () => showNode(2, true)
)
_inverse_transitions.push(
    () => showNode(2, false)
)

_transitions.push(
    () => showNode(3, true)
)
_inverse_transitions.push(
    () => showNode(3, false)
)

_transitions.push(
    () => showNode(4, true)
)
_inverse_transitions.push(
    () => showNode(4, false)
)

_transitions.push(
    () => showNode(5, true)
)
_inverse_transitions.push(
    () => showNode(5, false)
)

_transitions.push(
    () => showNode(6, true)
)
_inverse_transitions.push(
    () => showNode(6, false)
)

</script>

</body>

