<!-- Source: https://bl.ocks.org/mbostock/3231298 -->

<!DOCTYPE html>
<meta charset="utf-8">

<head>
  <style type="text/css">
        body { background-color: rgb(34, 34, 34);}
        .node { stroke: #fff; color: #eee; fill:azure; font-size: 40px; }

        .link { stroke: #999; stroke-opacity: .6; stroke-width: 10px; }

        .MathJax_SVG svg > g, 
        .MathJax_SVG_Display svg > g { 
            fill: rgb(240, 182, 182);
            stroke: rgb(235, 230, 230);
        } 
    </style>
</head>
<body>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js"></script>
<script>

var width = 960,
    height = 700;

data = undefined;
links = undefined;
nodes = undefined;
function loadGraph(json) {
  data = json;
  types = Array.from(new Set(data.links.map(d => d.type)));
  color = d3.scaleOrdinal(types, d3.schemeCategory10);

  links = data.links.map(d => Object.create(d));
  nodes = data.nodes.map(d => Object.create(d));

  const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id))
      .force("charge", d3.forceManyBody().strength(-800))
      .force("x", d3.forceX(width/2))
      .force("y", d3.forceY(height/3));

  drag = simulation => {
    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }
    
    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }
    
    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }
    
    return d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended);
  }
      
  const svg = d3.select("body").append("div").append("svg")
        .attr("viewBox", [0, 0, width, height])
        .style("font", "12px sans-serif")
        .style("width", "98%")
        .style("height", "98%");

  // Per-type markers, as they don't inherit styles.
  svg.append("defs").selectAll("marker")
    .data(types)
    .join("marker")
      .attr("id", d => `arrow-${d}`)
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 8)
      .attr("refY", -0.5)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
    .append("path")
      .attr("fill", color)
      .attr("d", "M0,-5L10,0L0,5");

  const link = svg.append("g")
      .attr("fill", "none")
      .attr("stroke-width", 2.0)
    .selectAll("path")
    .data(links)
    .join("path")
      .attr("stroke", d => color(d.type))
      .attr("marker-end", d => `url(${new URL(`#arrow-${d.type}`, location)})`)
      .attr("id", d => d.source.id + "-" + d.target.id)
      .attr("opacity", 0.0);

  const node = svg.append("g")
      .attr("fill", "white")
      .attr("stroke-linecap", "round")
      .attr("stroke-linejoin", "round")
    .selectAll("g")
    .data(nodes)
      .join("g")
        .attr("id", d => d.id)
        .attr("opacity", d => d.opacity)
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
    .call(drag(simulation));

  node.append(function(d) {
    const wrapNode = d3.create("svg:g");
    d.labels.forEach((label) => {
      if (label.math) {
        const mathNode = d3.create("svg:g");
        mathNode
          .style("text-anchor", "middle")
          .attr("transform", "translate(" + (label.offset || "0, 0") + ")")
          .attr("color", "#eee")
          .append(s => MathJax.tex2svg(label.math).querySelector("svg"));
        wrapNode.append(() => mathNode.node());
      } else if (label.text) {
        const textNode = d3.create("svg:text");
        textNode
          .style("text-anchor", "middle")
          .attr("transform", "translate(" + (label.offset || "0, 0") + ")")
          .attr("color", "#aae")
          .text(label.text);
        wrapNode.append(() => textNode.node());
      } else {
        throw "Node label contains no supported data!";
      }
    });
    return wrapNode.node();
  });

  simulation.on("tick", () => {
    link.attr("d", linkArc);
    node.attr("transform", d => `translate(${d.x},${d.y})`);
  });

}

if (window.frameElement && window.frameElement.parentNode.dataset.graph) {
    console.log("loading graph json:", window.frameElement.parentNode.dataset.graph);
    d3.json(window.frameElement.parentNode.dataset.graph).then(function(data) {
      loadGraph(data);
    }).catch(function(error) {
      console.log("Failed to load json file '" + window.frameElement.parentNode.dataset.graph + "'", error);
    });
  } else {
    // load some default graph
    d3.json("spota-graph.json").then(function(data) {
      loadGraph(data)
    });
  }

function getTotalBBox(eles) {
  let result = {x: 10000, y: 10000, width: 0, height: 0};
  eles.each(function(d, i) {
    var bb = d3.select(this).node().getBBox();
    var t = d3.select(this).attr("transform") || "(0, 0)";
    var offset = t.substring(t.indexOf("(")+1, t.indexOf(")")).split(",");
    result.x = Math.min(result.x, bb.x + Number(offset[0]));
    result.y = Math.min(result.y, bb.y + Number(offset[1]));
    result.width = Math.max(result.width, bb.x + bb.width - result.x + Number(offset[0]));
    result.height = Math.max(result.height, bb.y + bb.height - result.y + Number(offset[1]))
  });
  return result;
}

function getLinkAnchors(d) {
  const srcBB = getTotalBBox(d3.select("#" + d.source.id).selectAll("text"));
  const dstBB = getTotalBBox(d3.select("#" + d.target.id).selectAll("text"));
  var result = {start: {x: 0, y: 0}, end: {x: 0, y:0}};

  result.start.x = srcBB.x + 0.5*srcBB.width + d.source.x;
  result.start.y = srcBB.y + 0.5*srcBB.height + d.source.y;
  result.end.x = dstBB.x + 0.5*dstBB.width + d.target.x;
  result.end.y = dstBB.y + 0.5*dstBB.height + d.target.y;

  const srcPoints = [
    {x: srcBB.x + d.source.x, y: srcBB.y + d.source.y},
    {x: srcBB.x + srcBB.width + d.source.x, y: srcBB.y + d.source.y},
    {x: srcBB.x + srcBB.width + d.source.x, y: srcBB.y + srcBB.height + d.source.y},
    {x: srcBB.x + d.source.x, y: srcBB.y + srcBB.height + d.source.y}
  ];
  const dstPoints = [
    {x: dstBB.x + d.target.x, y: dstBB.y + d.target.y},
    {x: dstBB.x + dstBB.width + d.target.x, y: dstBB.y + d.target.y},
    {x: dstBB.x + dstBB.width + d.target.x, y: dstBB.y + dstBB.height + d.target.y},
    {x: dstBB.x + d.target.x, y: dstBB.y + dstBB.height + d.target.y}
  ]

  for (var i = 0; i < srcPoints.length; i++) {
    var det, gamma, lambda;
    var s1 = srcPoints[i];
    var s2 = i == srcPoints.length - 1 ? srcPoints[0] : srcPoints[i+1];
    det = (result.end.x - result.start.x) * (s2.y - s1.y) - (s2.x - s1.x) * (result.end.y - result.start.y);
    if (det === 0)
      continue;
    lambda = ((s2.y - s1.y) * (s2.x - result.start.x) + (s1.x - s2.x) * (s2.y - result.start.y)) / det;
    gamma = ((result.start.y - result.end.y) * (s2.x - result.start.x) + (result.end.x - result.start.x) * (s2.y - result.start.y)) / det;
    if ((0 < lambda && lambda < 1) && (0 < gamma && gamma < 1)) {
      // HIT!
      result.start.x = result.start.x + lambda * (result.end.x - result.start.x);
      result.start.y = result.start.y + lambda * (result.end.y - result.start.y);
      break;
    }
  }

  for (var i = 0; i < dstPoints.length; i++) {
    var det, gamma, lambda;
    var s1 = dstPoints[i];
    var s2 = i == dstPoints.length - 1 ? dstPoints[0] : dstPoints[i+1];
    det = (result.start.x - result.end.x) * (s2.y - s1.y) - (s2.x - s1.x) * (result.start.y - result.end.y);
    if (det === 0)
      continue;
    lambda = ((s2.y - s1.y) * (s2.x - result.end.x) + (s1.x - s2.x) * (s2.y - result.end.y)) / det;
    gamma = ((result.end.y - result.start.y) * (s2.x - result.end.x) + (result.start.x - result.end.x) * (s2.y - result.end.y)) / det;
    if ((0 < lambda && lambda < 1) && (0 < gamma && gamma < 1)) {
      // HIT!
      result.end.x = result.end.x + lambda * (result.start.x - result.end.x);
      result.end.y = result.end.y + lambda * (result.start.y - result.end.y);
      break;
    }
  }
  return result;
}

function linkArc(d) {
  var anchors = getLinkAnchors(d);
  const r = Math.hypot(anchors.end.x - anchors.start.x, anchors.end.y - anchors.start.y);
  return `
    M${anchors.start.x},${anchors.start.y}
    A${r},${r} 0 0,0 ${anchors.end.x},${anchors.end.y}
  `;
}


function showNode(idx, show) {
    let node_id;
    if (typeof idx == 'number') {
      node_id = nodes[idx].id;
    } else {
      node_id = idx;
    }
    node = d3.select("#" + node_id);
    
    if (show) {
        node.transition().attr("opacity", 1.0);
        
    } else {
        node.transition().attr("opacity", 0.0);
    }

    setTimeout(function() {
      var edges = [];
      links.forEach(link => {
          if (link.target.id == node_id && d3.select("#" + link.source.id).attr("opacity") > 0 ||
              link.source.id == node_id && d3.select("#" + link.target.id).attr("opacity") > 0)
            edges.push(link);
      });

      if (show) {
        edges.forEach(e => {
          d3.select("#" + e.source.id + "-" + e.target.id).transition().attr("opacity", 1.0);
            // var edge = d3.select("#" + e.source.id + "-" + e.target.id);
            // edge.attr("opacity", 1.0);
            // var length = edge.node().getTotalLength();
            // edge.attr("stroke-dasharray", length + " " + length)
            //     .attr("stroke-dashoffset", length)
            //     .transition().duration(600).ease(d3.easeBackOut).attr("stroke-dashoffset", 0);
        });
      } else {
        edges.forEach(e => {
            d3.select("#" + e.source.id + "-" + e.target.id).transition().attr("opacity", 0.0);
        });
      }
    }, 50);
}

function showNodes(idx, show, asyncDelay) {
  if (asyncDelay) {
    idx.forEach((i, d) => {
      setTimeout(function() {
      showNode(i, show);
    }, asyncDelay*d);
    });
    
  } else {
    idx.forEach((i) => {
      showNode(i, show);
    });
  }
}

function showAllNodes(show) {
  for (var i = 0; i < nodes.length; i++) {
    showNode(i, show);
  }
}

/// @fabio:
/// Slide transitions are defined here. Each transition is actually just a small lambda function. For both forward and backward steps through
///   the presentation to work, you need to define a function both for each transition AND one to un-do each transition (but the backward steps ARE optional if you don't care).
/// EXTRA NOTE: if you move INTO this slide by going BACKWARDS through the presentation, the LAST `transitionForward()` will be invoked. This gives you the
///   chance to build the final slide state and keep everything nice and continuous. This is why the last transition below enables ALL nodes instead of just the last one.
/// Here I have provided a small function which will toggle the visibility of a node, using its index in data.nodes[] above.
/// Arrow visibility is automatically set based on whether the nodes the arrow connects are visible.
///   e.g. `showNode(2, true)` will make the "evaluate in reference domains" node visible along with any arrows that connect this node to another visible node.
_transitions = [
  {
    transitionForward: () => {
      showNodes([1], true);
    },
    transitionBackward: () => showNodes([1], false),
    index: 0
  },
  {
    transitionForward: () => showNode(2, true),
    transitionBackward: () => showNode(2, false)
  },
  {
    transitionForward: () => showNode(3, true),
    transitionBackward: () => showNode(3, false)
  },
  {
    transitionForward: () => showNode(4, true),
    transitionBackward: () => showNode(4, false)
  },
  {
    transitionForward: () => showNode(5, true),
    transitionBackward: () => showNode(5, false)
  },
  {
    transitionForward: () => showNodes([6,5,4,3,2,1], true, 100),
    transitionBackward: () => showNode(6, false)
  }
];

document.addEventListener('keydown', function(e) {
  if (e.key == "o") {
    showAllNodes(true);
  }
});

/// @fabio: To manually load graph data (i.e. this page is not loaded in an iframe with "data-graph='filename.json'")
// d3.json("spota-graph.json").then(function(data) {
//   loadGraph(data);
// });

</script>

</body>

